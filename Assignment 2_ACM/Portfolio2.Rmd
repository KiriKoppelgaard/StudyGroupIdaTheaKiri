---
title: "Portfolio2"
author: "KK"
date: '2022-03-09'
output: html_document
---
During this assignment you wrap up the last few weeks of model exploration. You pick the model you have been working on and write a report:

- describing the model (you can re-use text from assignment 1, if relevant) 
We here take a closer look at the win-stay-lose-shift model.

- showcasing a commented version of the stan model (what does each line do?) 

- describing and motivating a process of parameter recovery (why are you doing it?, how are you doing it?) (nr of trials and combi of parameter values)

- report parameter recovery

- discussing the results: how many trials should be used at least to properly recover the parameters? Add relevant plot(s).

#Load libraries
```{r}
library(pacman)
p_load(tidyverse, here, posterior, cmdstanr, boot, brms)
```


#Load data and recode variables
```{r}
df <- read.csv('data/simulated_data.csv')
df <- df[0:120, ] #load data for single agent 
```

#Sensitivity check

```{r}

#Create priors 
prior_mean_bstay <- seq(-3, 3, .5)
prior_sd_bstay <- seq(0.1, 1, 0.1)

#Create all possible combinations 
priors <- expand.grid(prior_mean_bstay, prior_sd_bstay)


#reshape the data
priors <- tibble(prior_mean_bstay = priors$Var1, prior_sd_bstay=priors$Var2)

```


#Include output variables for prior and for predictive checks
```{r}
stan_file <- write_stan_file("
// This Stan model infers a rate (theta) from a number of trials (n) and successes (k)

// The input data is two integer numbers: n and k.
data {
  int <lower=1> n; // n of trials 
  array[n]int k;  // choices
  vector<lower=-1, upper=1>[n] win; //stay bias
  vector<lower=-1, upper=1>[n] lose; //leave bias
  real prior_mean_bstay; 
  real <lower = 0> prior_sd_bstay;
}

// The parameters accepted by the model. Our model accepts only theta, the rate, 
// which is bound at 0 (no chances of success) and 1 (always success)
parameters {
  real alpha;
  real beta_stay;
  real beta_leave;
}

transformed parameters{
  vector[n] theta;
  theta = alpha + (beta_stay*win)+ (beta_leave*lose); //multiplying the paramaters we want to estimate on the data
}

// The model to be estimated; prior and likelihood
model {
  // The prior for theta is a uniform distribution between 0 and 1
  target += normal_lpdf(alpha | 0, 1);
  target += normal_lpdf(beta_stay | prior_mean_bstay, prior_sd_bstay);
  target += normal_lpdf(beta_leave | 0, 0.3);

  // The model consists in a binomial distribution with a rate theta, 
  // and a number of trials n generating k successes
  target += bernoulli_logit_lpmf(k | theta);
}

generated quantities{
  real bstay_prior;
  real bstay_posterior;
  int<lower=0, upper=n> prior_preds;
  array[n] int <lower=0, upper=n> posterior_preds;

  bstay_prior = normal_rng(0,1);
  bstay_posterior = beta_stay;
  
  prior_preds = binomial_rng(n, inv_logit(bstay_prior));
  posterior_preds = binomial_rng(n, inv_logit(theta));
}

")

```

Technically you could access parameter values all four possible conditions as follows: 

- posteriorWH_preds = binomial_rng(n, inv_logit(alpha + beta_stay*1 + beta_leave*0));


```{r}
#Compile the model
mod <- cmdstan_model(stan_file, cpp_options = list(stan_threads = TRUE), pedantic = TRUE)

```

```{r, eval = false}
sensitivity_df <- NULL

for (p in seq(nrow(priors))){
  data <- list(
    n = 120, 
    k = df$Self[0:120],
    win = df$win[0:120],
    lose = df$lose[0:120],
    prior_mean_bstay = priors$prior_mean_bstay[p],
    prior_sd_bstay = priors$prior_sd_bstay[p]
  )
  
  samples <- mod$sample(
  data = data,
  seed = 123,
  chains = 1,
  parallel_chains = 1,
  threads_per_chain = 1,
  iter_warmup = 1000,
  iter_sampling = 1000,
  refresh = 1000,
  max_treedepth = 20,
  adapt_delta = 0.99)
  
  draws_df <- as_draws_df(samples$draws())
  
  temp <- tibble(bstay_prior = draws_df$bstay_prior, 
                 bstay_posterior = draws_df$bstay_posterior,
                 prior_preds = draws_df$prior_preds, 
                 posterior_preds = draws_df$posterior_preds, 
                 prior_mean_bstay = priors$prior_mean_bstay[p],
                 prior_sd_bstay = priors$prior_sd_bstay[p]
                 )
  if(exists("sensitivity_df")){sensitivity_df <- rbind (sensitivity_df, temp)} else {sensitivity_df <- temp}
  
}
```


#Include a prior sensitivity plot
```{r}
#Plot of mean
ggplot(data=sensitivity_df, aes(x=prior_mean_bstay, y=inv.logit(bstay_posterior))) +
  facet_wrap(~ prior_sd_bstay) + 
  geom_point(size = 3, alpha = .3) +
  geom_hline(yintercept = 0.9, color = 'red', linetype = 'dashed') + 
  labs(x="Mean", y="Posterior", title = 'Prior Sensitivity Check for Beta Stay')+ 
  theme_bw()

#Plot of sd
ggplot(data=sensitivity_df, aes(x=prior_sd_bstay, y=inv.logit(bstay_posterior))) +
  facet_wrap(~ prior_mean_bstay) + 
  geom_point(size = 3, alpha = .3) +
  geom_hline(yintercept = 0.9, color = 'red', linetype = 'dashed') + 
  labs(x="SD", y="Posterior", title = 'Prior Sensitivity Check for Beta Stay')+ 
  theme_bw()
  
```

#Perform parameter recovery
```{r}
#Load simulated data with different rates
recovery_trials_df <- read.csv('data/simulated_data.csv')

```


```{r}
stan_file <- write_stan_file("
// This Stan model infers two rates; a StayBias and a LeaveBias to model a WSLS agent

// The input data is 
data {
  int <lower=1> n; // n of trials 
  array[n]int k;  // choices; 0 = tails, 1 = heads
  vector<lower=-1, upper=1>[n] win; //stay bias
  vector<lower=-1, upper=1>[n] lose; //leave bias
}

// The parameters accepted by the model. Our model accepts only theta, the rate, 
// which is bound at 0 (no chances of success) and 1 (always success)
parameters {
  real alpha; // intercept
  real beta_stay; // the prosensity to stay, given the agent won
  real beta_leave; //the propensity to leave, given the agent lost
}

transformed parameters{
  vector[n] theta; // theta is a vector of same length as n trials
  theta = alpha + (beta_stay*win) + (beta_leave*lose); // the model
}

// The model to be estimated; prior and likelihood
model {
  // The prior for theta is a normal distribution between 0 and 1
  target += normal_lpdf(alpha | 0, 1); // prior for alpha is a normal distribution with a mean of 0 and sd of 1. Hereby, we assume that there is equal chance of choosing heads or tails regardless of anything else  
  target += normal_lpdf(beta_stay | 0, 0.3); // setting prior for StayBias
  target += normal_lpdf(beta_leave | 0, 0.3); // setting prior for LeaveBias

  // The model 
  target += bernoulli_logit_lpmf(k | theta); // the data given theta aka the model
}
// This block quantifies the 
generated quantities{
  real leavebias_posterior;
  real staybias_posterior;

  staybias_posterior = beta_stay;
  leavebias_posterior = beta_leave;
  
}

")
```

```{r}
#Compile the model
mod <- cmdstan_model(stan_file, cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
```

#Parameter recovery: LeaveBias

```{r}
#maintain constant staybias
df <- recovery_trials_df[recovery_trials_df$staybias == 0.7,]
#c(10, 25, 50, 100, 200, 500, 1000, 2500, 5000)

for (leavebias in unique(df$leavebias)){
  for (trial_n in c(10)){
    df <- df[df$leavebias == leavebias, ] 
    
    data <- list(
      n = trial_n, 
      k = df$Self[0:trial_n],
      win = df$win[0:trial_n],
      lose = df$lose[0:trial_n]
    )
    
    samples <- mod$sample(
    data = data,
    seed = 123,
    chains = 1,
    parallel_chains = 1,
    threads_per_chain = 1,
    iter_warmup = 1000,
    iter_sampling = 1000,
    refresh = 1000,
    max_treedepth = 20,
    adapt_delta = 0.99)
    
    draws_df <- as_draws_df(samples$draws())
    
    temp <- tibble(
                   leavebias_posterior = draws_df$leavebias_posterior
                   )
    if(exists("param_leave_df")){param_leave_df <- rbind (param_leave_df, temp)} else {param_leave_df <- temp}
  }  
}

```


#Parameter recovery: StayBias

